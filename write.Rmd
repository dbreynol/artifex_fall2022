# Time Series

## Decomposition

We want to decompose our time series into three parts: a trend component ($T$), a seasonality component ($S$), and a random component ($R$). That is, for each observation $Y_t$, we want to break it down into three parts:

$Y_T = T_t + S_t + R_t$

First, let's talk about the trend component (T). The trend component is a moving average, which you can obtain using the <code>ma</code> function within the *forecast* library.

```{r echo=TRUE}
set.seed(1)

# generate some fake data that resembles our real dataset (noce the week_no variable, which 
# corresponds with the enterprise week number from your original data)

trend = seq( from = 10, to = 10 + 52 * 3 - 1, by = 1)

df = data.frame( invoiced = trend + (rnorm(52 * 3, mean = 25, sd = 40)), 
                 week_no = rep(1:52, 3), # week number
                 id = 1:(52 * 3)) 
plot(df$invoiced, type = "l")

y_ts = ts(df$invoiced, frequency = 52) # make your data into a time series object
df$trend = ma(y_ts, order = 52) # use the ma function from the forecast library
```

Now that we have added a trend variable to our data frame, let's get the seasonal ($S$) component. To estimate the seasonal component for each week, simply average the detrended values for that week. These seasonal component values are then adjusted to ensure that they add to zero.

```{r, echo=T}
# 1. subtract the trend
df$detrend = df$invoiced - df$trend

# 2. group by week number and take the average of the de-trended values
df = df %>% group_by(week_no) %>% 
  mutate(S1 = mean(detrend, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(S = S1 - mean(S1)) %>% # make sure the sum of the seasonal components is 0
  select(!c(detrend, S1))
```

Finally, the random component is calculated by subtracting the estimated seasonal and trend-cycle components. That is, 

$R_t = Y_t - T_t - S_t$.

```{r, echo=TRUE}
df = mutate(df, R = invoiced - trend - S)
```

Now, plot each line:

```{r echo=TRUE, warning=FALSE, message=FALSE}
df %>% 
  pivot_longer(!(c("week_no", "id"))) %>% 
  ggplot(aes(id, value, color = name)) + 
  geom_line() + 
  theme_minimal() + 
  ggtitle("Decomposition of invoiced time series")
```

## Forecasting

Simple exponential smoothing - forecast the next value as a weighted average of past values.

```{r echo=TRUE}

fx1 <- ses(y_ts, h=5)
fx2 <- holt(y_ts, h=15)

round(accuracy(fx1),2)

autoplot(y_ts) +
  autolayer(fx1, series="Simple Exponential Smoothing", PI=F) +
  autolayer(fx2, series="Holt Winters", PI=F) + 
  ylab("Invoiced") + xlab("Year")
```













